## Item 85. 자바 직렬화의 대안을 찾아라
***

직렬화의 근본적인 문제는 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는 점입니다.

`ObjectInputStream` 의 `readObject` 메서드를 호출하면서 객체 그래프가 역직렬화
되기 때문입니다.

`readObject` 메서드는 클래스패스 안의 거의 모든 타입의 객체를 만들러 낼 수 있는, 사실상 마법 같은 생성자 입니다.

바이트 스트림을 역직렬화하는 과정에서 이 메서드는 그 타입들 안의 모든 코드를 수행할 수 있습니다.

즉, 그 타입들의 코드 전체가 공격 범위에 들어간다는 뜻입니다.

공격자와 보안 전문가들은 자바 라이브러리와 널리 쓰이는 서드파티 라이브러리에서 직렬화 가능
타입들을 연구하여 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드 들을 찾아 보았습니다.

이런 메서드를 가젯이라고 부릅니다. 가젯을 이용하여 가젯 체인을 만들 수 있으며, 또한 공격자가 하드웨어의 네이티브 코드를 마음대로
실행할 수 있는 가젯 체인도 있습니다. 그래서 아주 신중하게 제작한 바이트 스트리만 역직렬화 해야합니다.

가젯까지도 갈 것 없이, 역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화하는 것만으로도 서비스 거부 공격에 쉽게 노출될 수 있습니다.

다음의 예를 봅시다.

```java
static byte[] bomb(){
    Set<Object> root = new HashSet<>();
    Set<Object> s1 = root;
    Set<Object> s2 = new HashSet<>();
    for (int i = 0 ; i < 100 ; i++){
        Set<Object> t1 = new HashSet<>();
        Set<Object> t2 = new HashSet<>();
        t1.add("foo");
        s1.add(t1);
        s1.add(t2);
        s2.add(t1);
        s2.add(t2);
    }
    return serialize(root);
}
```

이 객체 그래프는 201개의 `HashSet` 인스턴스로 구성되며, 그 각각은 3개 이하의 객체 참조를 갖습니다.
스트림의 전체 크기는 5,744 바이트지만, 역직렬화는 절대 끝나지 않을 것입니다.

문제는 `HashSet` 인스턴스를 역직렬화하려면 그 원소들의 해시코드를 계산해야한다는 것입니다.
루트 `HashSet`에 담긴 두 원소는 각각 다른 `HashSet` 2개씩 원소를 갖습니다.

그리고 반복문에 의해 이 구조가 깊이 100단계 까지 만들어집니다. 따라서 이 `HashSet`을 역직렬화하려면 `hashcode`를 2의 100 제곱번 넘게
호출해야합니다.

역직렬화가 영원히 계속된다는 것도 문제지만, 무언가 잘못되었다는 신호주차 주지 않는 다는 것도 문제입니다. 이 코드는 단 몇 개의 객체만
생성해도 `StackOverFlow`가 발생합니다.

그렇다면 문제를 어떻게 대처해야 할까요?? 애초에 신뢰할 수 없는 바이트 스트림을 역직렬화하는 일 자체가 스스로를 공격에 노출하는 행위입니다.

**따라서 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것입니다.**

마찬가지로 **작성하는 새로운 시스템에서 자바 직렬화를 써야 할 이유는 전혀 없습니다.**

객체와 바이트 시퀀스를 변환해주는 다른 메커니즘이 많이 있습니다. 이 방식들은 자바 직렬화의 여러 위험을 회피하면서 다양한 플랫폼 지원, 우수한 성능, 풍부한 지원 도구,
활발한 커뮤니티와 전문가 집단 등 수많은 이점까지 제공합니다.

임의 객체 그래프를 자동으로 직렬화/역직렬화 하지 않고, 속성-값 쌍의 집합으로 구성된 간단하고 구조화된 데이터 객체를 사용하빈다.

그리고 기본 타입 몇 개와 배열 타입만 지원할 뿐입니다. 이런 간단한 추상화 만으로도 아주 강격한 분산 시스템을 구축하기에 충분하고, 자바 직렬화가 가져온 심각한 문제들을
회피할 수 있습니다.

이런 방식들 중 대표적으로는 `Json` 과 `Protobuf` 가 있습니다.
`Json`은 브라우저와 서버의 통신용으로 설계했고, 프로토콜 버퍼는 구글이 서버 사이에 데이터를 교환하고 저장하기 위해 설계했습니다.

둘의 가장 큰 차이는 `Json`은 텍스트 기반이라 사람이 읽을 수 있고, 프로토콜 버퍼는 이진 표현이라 효율이 높습니다.

레거시 시스템 때문에 자바 직렬화를 완전히 배제할 수 없을 때의 차선책은 **신뢰할 수 없는 데이터는 절대 역직렬화 하지 않는 것 입니다.**

직렬화를 피할 수 없고 역직렬화한 데이터가 안전한지 완전히 확신할 수 없다면 객체 역직렬화 필터링을 사용합시다.
클래스 단위로, 특정 클래스를 받아 들이거나 거부할 수 있습니다.

두 가지 모드 '기본 수용', '기본 거부' 모드가 있으며 각각 블랙리스트, 화이트리스트 방식을 사용합니다.
일반적으로 화이트리스트 방식을 더 추천한다고 합니다. 블랙리스트 방식은 이미 알려진 공격으로 부터만 방어가 가능하기 때문입니다.